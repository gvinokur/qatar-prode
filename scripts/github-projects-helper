#!/usr/bin/env python3
"""
GitHub Projects Helper
A CLI tool to streamline GitHub Projects operations for story-based development workflow.
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class Colors:
    """ANSI color codes for terminal output."""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'


class GitHubProjectsHelper:
    """Helper class for GitHub Projects operations."""

    def __init__(self, repo_path: str = "."):
        self.repo_path = Path(repo_path).resolve()
        self.owner = None
        self.repo_name = None
        self._project_fields_cache = {}  # Cache for project fields
        self._load_repo_info()

    def _load_repo_info(self):
        """Load repository owner and name from git remote."""
        try:
            result = self._run_command(
                ["gh", "repo", "view", "--json", "owner,name"],
                capture_output=True
            )
            data = json.loads(result.stdout)
            self.owner = data["owner"]["login"]
            self.repo_name = data["name"]
        except Exception as e:
            self._error(f"Failed to load repository info: {e}")
            sys.exit(1)

    def _run_command(
        self,
        cmd: List[str],
        capture_output: bool = True,
        check: bool = True,
        cwd: Optional[Path] = None
    ) -> subprocess.CompletedProcess:
        """Run a shell command and return the result."""
        try:
            return subprocess.run(
                cmd,
                capture_output=capture_output,
                text=True,
                check=check,
                cwd=cwd or self.repo_path
            )
        except subprocess.CalledProcessError as e:
            self._error(f"Command failed: {' '.join(cmd)}")
            if e.stderr:
                print(e.stderr, file=sys.stderr)
            raise

    def _print(self, msg: str, color: str = Colors.RESET):
        """Print colored message."""
        print(f"{color}{msg}{Colors.RESET}")

    def _success(self, msg: str):
        """Print success message."""
        self._print(f"âœ“ {msg}", Colors.GREEN)

    def _error(self, msg: str):
        """Print error message."""
        self._print(f"âœ— {msg}", Colors.RED)

    def _warning(self, msg: str):
        """Print warning message."""
        self._print(f"âš  {msg}", Colors.YELLOW)

    def _info(self, msg: str):
        """Print info message."""
        self._print(f"â„¹ {msg}", Colors.CYAN)

    def _header(self, msg: str):
        """Print header message."""
        self._print(f"\n{Colors.BOLD}{msg}{Colors.RESET}", Colors.BLUE)

    # ==================== PROJECT FIELD OPERATIONS ====================

    def _get_project_fields(self, project_number: int) -> Dict:
        """Fetch and cache project fields including status options."""
        cache_key = f"project_{project_number}_fields"

        if cache_key in self._project_fields_cache:
            return self._project_fields_cache[cache_key]

        try:
            result = self._run_command([
                "gh", "project", "field-list", str(project_number),
                "--owner", self.owner,
                "--format", "json",
                "--limit", "100"
            ])
            data = json.loads(result.stdout)
            self._project_fields_cache[cache_key] = data
            return data
        except Exception as e:
            self._warning(f"Could not fetch project fields: {e}")
            return {"fields": []}

    def _find_status_field(self, project_number: int) -> Optional[Dict]:
        """Find the Status field in the project."""
        fields_data = self._get_project_fields(project_number)

        for field in fields_data.get("fields", []):
            # Look for Status field (case-insensitive)
            if field.get("name", "").lower() == "status" and field.get("type") == "ProjectV2SingleSelectField":
                return field

        return None

    def _match_status_option(self, status_field: Dict, semantic_names: List[str]) -> Optional[Dict]:
        """
        Match status option by semantic names.

        Args:
            status_field: The status field dict with options
            semantic_names: List of possible names to match (e.g., ["In Progress", "In Dev", "Working"])

        Returns:
            Dict with 'id' and 'name' of matched option, or None
        """
        options = status_field.get("options", [])

        # Try exact match first (case-insensitive)
        for semantic_name in semantic_names:
            for option in options:
                if option.get("name", "").lower() == semantic_name.lower():
                    return option

        # Try partial match
        for semantic_name in semantic_names:
            for option in options:
                option_name = option.get("name", "").lower()
                semantic_lower = semantic_name.lower()
                if semantic_lower in option_name or option_name in semantic_lower:
                    return option

        return None

    def _get_project_item_id(self, project_number: int, issue_number: int) -> Optional[str]:
        """Get the project item ID for a given issue."""
        try:
            result = self._run_command([
                "gh", "project", "item-list", str(project_number),
                "--owner", self.owner,
                "--format", "json",
                "--limit", "500"
            ])
            data = json.loads(result.stdout)

            for item in data.get("items", []):
                content = item.get("content", {})
                if content.get("number") == issue_number:
                    return item.get("id")

            return None
        except Exception as e:
            self._warning(f"Could not find project item: {e}")
            return None

    def _update_project_item_status(
        self,
        project_number: int,
        issue_number: int,
        status_name: str
    ) -> bool:
        """
        Update project item status using semantic matching.

        Args:
            project_number: The project number
            issue_number: The issue number
            status_name: Semantic status name (e.g., "In Progress", "Pending Review", "Done")

        Returns:
            True if successful, False otherwise
        """
        # Get project fields to find status field
        status_field = self._find_status_field(project_number)
        if not status_field:
            self._warning("Status field not found in project")
            return False

        # Define semantic mappings
        semantic_map = {
            "in_progress": ["In Progress", "In Dev", "In Development", "Working", "Started"],
            "pending_review": ["Pending Review", "In Review", "Review", "Ready for Review"],
            "done": ["Done", "Completed", "Closed", "Finished"]
        }

        # Determine which semantic group to search
        status_lower = status_name.lower()
        search_names = []

        if any(x in status_lower for x in ["progress", "dev", "working", "started"]):
            search_names = semantic_map["in_progress"]
        elif any(x in status_lower for x in ["review", "pending"]):
            search_names = semantic_map["pending_review"]
        elif any(x in status_lower for x in ["done", "complete", "close", "finish"]):
            search_names = semantic_map["done"]
        else:
            # Fallback: try exact match with provided name
            search_names = [status_name]

        # Find matching status option
        status_option = self._match_status_option(status_field, search_names)
        if not status_option:
            self._warning(f"Could not find status option matching: {status_name}")
            return False

        # Get project item ID
        item_id = self._get_project_item_id(project_number, issue_number)
        if not item_id:
            self._warning(f"Could not find project item for issue #{issue_number}")
            return False

        # Get project global ID (need to query GraphQL for this)
        try:
            # First get project ID using GraphQL
            query = '''
            query($owner: String!, $number: Int!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                }
              }
            }
            '''

            result = self._run_command([
                "gh", "api", "graphql",
                "-f", f"query={query}",
                "-F", f"owner={self.owner}",
                "-F", f"number={project_number}"
            ])
            project_data = json.loads(result.stdout)
            project_id = project_data.get("data", {}).get("user", {}).get("projectV2", {}).get("id")

            if not project_id:
                self._warning("Could not get project ID")
                return False

            # Now update the status using GraphQL mutation
            mutation = '''
            mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
              updateProjectV2ItemFieldValue(
                input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: {
                    singleSelectOptionId: $optionId
                  }
                }
              ) {
                projectV2Item {
                  id
                }
              }
            }
            '''

            self._run_command([
                "gh", "api", "graphql",
                "-f", f"query={mutation}",
                "-f", f"projectId={project_id}",
                "-f", f"itemId={item_id}",
                "-f", f"fieldId={status_field['id']}",
                "-f", f"optionId={status_option['id']}"
            ])

            self._success(f"Updated status to: {status_option['name']}")
            return True

        except Exception as e:
            self._warning(f"Could not update project status: {e}")
            return False

    # ==================== PROJECT OPERATIONS ====================

    def list_projects(self) -> List[Dict]:
        """List all projects for the repository owner."""
        self._header("Fetching projects...")

        result = self._run_command(
            ["gh", "project", "list", "--owner", self.owner, "--format", "json"]
        )
        data = json.loads(result.stdout)
        projects = [p for p in data.get("projects", []) if not p.get("closed", False)]

        if not projects:
            self._warning("No open projects found")
            return []

        for project in projects:
            self._print(f"\n{Colors.BOLD}Project #{project['number']}: {project['title']}{Colors.RESET}")
            print(f"  URL: {project['url']}")
            print(f"  Items: {project['items']['totalCount']}")
            if project.get('shortDescription'):
                print(f"  Description: {project['shortDescription']}")

        return projects

    def get_project_stats(self, project_number: int) -> Dict:
        """Get detailed statistics for a project."""
        self._header(f"Fetching project #{project_number} statistics...")

        result = self._run_command([
            "gh", "project", "item-list", str(project_number),
            "--owner", self.owner,
            "--format", "json",
            "--limit", "500"
        ])
        data = json.loads(result.stdout)
        items = data.get("items", [])

        if not items:
            self._warning("No items found in project")
            return {}

        # Calculate statistics
        stats = {
            "total": len(items),
            "by_status": {},
            "by_priority": {},
            "by_milestone": {},
            "by_effort": {},
            "by_category": {}
        }

        for item in items:
            # Status breakdown
            status = item.get("status", "Unknown")
            stats["by_status"][status] = stats["by_status"].get(status, 0) + 1

            # Priority breakdown
            priority = item.get("priority", "Unknown")
            stats["by_priority"][priority] = stats["by_priority"].get(priority, 0) + 1

            # Milestone breakdown
            milestone = item.get("milestone", {})
            if milestone:
                milestone_title = milestone.get("title", "No Milestone")
                stats["by_milestone"][milestone_title] = stats["by_milestone"].get(milestone_title, 0) + 1

            # Effort breakdown
            effort = item.get("effort", "Unknown")
            stats["by_effort"][effort] = stats["by_effort"].get(effort, 0) + 1

            # Category breakdown
            category = item.get("category", "Unknown")
            stats["by_category"][category] = stats["by_category"].get(category, 0) + 1

        # Print statistics
        self._print(f"\n{Colors.BOLD}Total Items: {stats['total']}{Colors.RESET}")

        self._print(f"\n{Colors.BOLD}By Status:{Colors.RESET}")
        for status, count in sorted(stats["by_status"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {status}: {count}")

        self._print(f"\n{Colors.BOLD}By Priority:{Colors.RESET}")
        priority_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3}
        for priority, count in sorted(stats["by_priority"].items(), key=lambda x: priority_order.get(x[0], 99)):
            emoji = {"Critical": "ðŸ”¥ðŸ”¥ðŸ”¥", "High": "ðŸ”¥ðŸ”¥", "Medium": "ðŸ”¥", "Low": "â­"}.get(priority, "")
            print(f"  {emoji} {priority}: {count}")

        self._print(f"\n{Colors.BOLD}By Milestone:{Colors.RESET}")
        for milestone, count in sorted(stats["by_milestone"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {milestone}: {count}")

        self._print(f"\n{Colors.BOLD}By Effort:{Colors.RESET}")
        for effort, count in sorted(stats["by_effort"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {effort}: {count}")

        return stats

    # ==================== STORY OPERATIONS ====================

    # TODO: Add story/issue creation functionality
    # Similar to the scripts used before to create all the UX improvement issues
    # Should support:
    # - Creating issues from templates or JSON input
    # - Auto-assigning to projects
    # - Setting fields (priority, effort, milestone, category)
    # - Bulk creation from CSV/JSON files
    # - Template-based issue creation with variable substitution
    # Example: ./scripts/github-projects-helper stories create --from-file stories.json --project 1

    def suggest_stories(
        self,
        project_number: int,
        milestone: Optional[str] = None,
        priority: Optional[str] = None,
        limit: int = 5
    ) -> List[Dict]:
        """Suggest candidate stories to work on."""
        self._header("Analyzing candidate stories...")

        result = self._run_command([
            "gh", "project", "item-list", str(project_number),
            "--owner", self.owner,
            "--format", "json",
            "--limit", "500"
        ])
        data = json.loads(result.stdout)
        items = data.get("items", [])

        # Filter eligible stories
        candidates = []
        for item in items:
            status = item.get("status", "")
            item_priority = item.get("priority", "")
            item_milestone = item.get("milestone", {}).get("title", "") if item.get("milestone") else ""

            # Filter criteria
            if status not in ["Todo", "Ready"]:
                continue
            if priority and item_priority != priority:
                continue
            if milestone and item_milestone != milestone:
                continue

            # Calculate score for prioritization
            priority_scores = {"Critical": 10, "High": 7, "Medium": 5, "Low": 3}
            effort_scores = {"Low 1d-2s": 3, "Medium 3d-5d": 2, "High 5d-10d": 1}

            score = priority_scores.get(item_priority, 0) + effort_scores.get(item.get("effort", ""), 0)

            candidates.append({
                "item": item,
                "score": score
            })

        # Sort by score and limit
        candidates.sort(key=lambda x: x["score"], reverse=True)
        top_candidates = candidates[:limit]

        if not top_candidates:
            self._warning("No candidate stories found matching criteria")
            return []

        self._print(f"\n{Colors.BOLD}Top {len(top_candidates)} Candidate Stories:{Colors.RESET}\n")

        for i, candidate in enumerate(top_candidates, 1):
            item = candidate["item"]
            content = item.get("content", {})
            number = content.get("number", "?")
            title = item.get("title", "Untitled")
            priority_val = item.get("priority", "Unknown")
            effort = item.get("effort", "Unknown")
            milestone_val = item.get("milestone", {}).get("title", "No Milestone") if item.get("milestone") else "No Milestone"

            priority_emoji = {"Critical": "ðŸ”¥ðŸ”¥ðŸ”¥", "High": "ðŸ”¥ðŸ”¥", "Medium": "ðŸ”¥", "Low": "â­"}.get(priority_val, "")

            self._print(f"{i}. {Colors.BOLD}#{number}: {title}{Colors.RESET}")
            print(f"   Priority: {priority_emoji} {priority_val}")
            print(f"   Effort: {effort}")
            print(f"   Milestone: {milestone_val}")
            print(f"   Score: {candidate['score']}/13")
            print()

        return [c["item"] for c in top_candidates]

    def start_story(self, issue_number: int, project_number: Optional[int] = None) -> Dict:
        """
        Start working on a story:
        1. Create worktree with feature branch
        2. Copy environment files
        3. Assign issue to current user
        4. Update project status to "In Progress"
        """
        self._header(f"Starting work on story #{issue_number}...")

        # Get issue details
        self._info("Fetching issue details...")
        result = self._run_command([
            "gh", "issue", "view", str(issue_number),
            "--json", "number,title,body,labels,milestone"
        ])
        issue = json.loads(result.stdout)

        # Create branch and worktree
        branch_name = f"feature/story-{issue_number}"
        worktree_path = self.repo_path.parent / f"{self.repo_name}-story-{issue_number}"

        self._info(f"Creating worktree at {worktree_path}...")

        if worktree_path.exists():
            self._error(f"Worktree already exists at {worktree_path}")
            sys.exit(1)

        self._run_command([
            "git", "worktree", "add", "-b", branch_name, str(worktree_path)
        ])
        self._success(f"Worktree created: {worktree_path}")

        # Copy environment files
        env_file = self.repo_path / ".env.local"
        if env_file.exists():
            self._info("Copying .env.local file...")
            target_env = worktree_path / ".env.local"
            target_env.write_text(env_file.read_text())
            self._success("Environment files copied")
        else:
            self._warning(".env.local not found - you may need to create it manually")

        # Assign issue to current user
        self._info("Assigning issue to you...")
        self._run_command([
            "gh", "issue", "edit", str(issue_number),
            "--add-assignee", "@me"
        ])
        self._success("Issue assigned")

        # Update project status if project number provided
        if project_number:
            self._info("Updating project status to 'In Progress'...")
            success = self._update_project_item_status(project_number, issue_number, "In Progress")
            if not success:
                self._warning("Could not update project status automatically - please update manually")

        # Print summary
        self._header("Setup Complete!")
        print(f"  Worktree: {Colors.GREEN}{worktree_path}{Colors.RESET}")
        print(f"  Branch: {Colors.GREEN}{branch_name}{Colors.RESET}")
        print(f"  Issue: {Colors.GREEN}#{issue_number}: {issue['title']}{Colors.RESET}")
        print(f"\n  Next steps:")
        print(f"    1. Plan the work: Ask Claude to 'plan work for story #{issue_number}'")
        print(f"    2. The worktree is ready at: {worktree_path}")

        return {
            "worktree_path": str(worktree_path),
            "branch_name": branch_name,
            "issue_number": issue_number,
            "issue_title": issue["title"]
        }

    # ==================== PR OPERATIONS ====================

    def wait_for_checks(self, pr_number: int, timeout: int = 1800, poll_interval: int = 30) -> Dict:
        """
        Wait for PR checks to complete (Vercel, SonarCloud).
        Returns status of all checks.
        """
        self._header(f"Waiting for PR #{pr_number} checks to complete...")
        self._info(f"Timeout: {timeout}s, Poll interval: {poll_interval}s")

        start_time = time.time()

        while True:
            elapsed = time.time() - start_time
            if elapsed > timeout:
                self._error("Timeout waiting for checks to complete")
                sys.exit(1)

            # Get check status
            result = self._run_command([
                "gh", "pr", "checks", str(pr_number),
                "--json", "name,state,bucket"
            ])
            checks = json.loads(result.stdout)

            # Find Vercel and SonarCloud checks
            vercel_check = next((c for c in checks if "vercel" in c["name"].lower()), None)
            sonar_check = next((c for c in checks if "sonar" in c["name"].lower()), None)

            if not vercel_check and not sonar_check:
                self._warning("No Vercel or SonarCloud checks found - waiting...")
                time.sleep(poll_interval)
                continue

            # Checks are done when state is SUCCESS or FAILURE (not IN_PROGRESS or PENDING)
            vercel_done = vercel_check and vercel_check.get("state") in ["SUCCESS", "FAILURE", "CANCELLED"] if vercel_check else True
            sonar_done = sonar_check and sonar_check.get("state") in ["SUCCESS", "FAILURE", "CANCELLED"] if sonar_check else True

            # Print status
            status_line = f"[{int(elapsed)}s] "
            if vercel_check:
                status_line += f"Vercel: {vercel_check.get('state', 'UNKNOWN')} "
            if sonar_check:
                status_line += f"SonarCloud: {sonar_check.get('state', 'UNKNOWN')}"
            print(status_line)

            if vercel_done and sonar_done:
                break

            time.sleep(poll_interval)

        # Print final results
        self._header("Checks Complete!")

        results = {}
        if vercel_check:
            bucket = vercel_check.get("bucket", "UNKNOWN")
            state = vercel_check.get("state", "UNKNOWN")
            # bucket can be: pass, fail, pending
            # Use state for more accurate status
            if bucket == "pass" or state == "SUCCESS":
                self._success(f"Vercel: PASS")
                results["vercel"] = "PASS"
            elif bucket == "fail":
                self._error(f"Vercel: FAIL")
                results["vercel"] = "FAIL"
            else:
                self._warning(f"Vercel: {bucket}")
                results["vercel"] = bucket

        if sonar_check:
            bucket = sonar_check.get("bucket", "UNKNOWN")
            state = sonar_check.get("state", "UNKNOWN")
            if bucket == "pass" or state == "SUCCESS":
                self._success(f"SonarCloud: PASS")
                results["sonar"] = "PASS"
            elif bucket == "fail":
                self._error(f"SonarCloud: FAIL")
                results["sonar"] = "FAIL"
            else:
                self._warning(f"SonarCloud: {bucket}")
                results["sonar"] = bucket

        # Get PR URL for preview
        result = self._run_command([
            "gh", "pr", "view", str(pr_number),
            "--json", "url"
        ])
        pr_data = json.loads(result.stdout)
        print(f"\nPR URL: {pr_data['url']}")

        return results

    def complete_story(
        self,
        issue_number: int,
        pr_number: Optional[int] = None,
        merge_method: str = "squash",
        project_number: Optional[int] = None
    ) -> bool:
        """
        Complete a story:
        1. Verify checks pass
        2. Merge PR
        3. Close issue
        4. Clean up worktree
        """
        self._header(f"Completing story #{issue_number}...")

        # Find PR if not provided
        if not pr_number:
            self._info("Finding PR for story...")
            result = self._run_command([
                "gh", "pr", "list",
                "--head", f"feature/story-{issue_number}",
                "--json", "number",
                "--limit", "1"
            ])
            prs = json.loads(result.stdout)
            if not prs:
                self._error(f"No PR found for story #{issue_number}")
                sys.exit(1)
            pr_number = prs[0]["number"]
            self._success(f"Found PR #{pr_number}")

        # Check if PR is mergeable
        self._info("Checking if PR is mergeable...")
        result = self._run_command([
            "gh", "pr", "view", str(pr_number),
            "--json", "mergeable,state"
        ])
        pr_data = json.loads(result.stdout)

        if pr_data["state"] != "OPEN":
            self._error(f"PR is not open (state: {pr_data['state']})")
            sys.exit(1)

        if pr_data["mergeable"] != "MERGEABLE":
            self._error(f"PR is not mergeable (status: {pr_data['mergeable']})")
            sys.exit(1)

        # Merge PR (don't delete branch yet - worktree still using it)
        self._info(f"Merging PR #{pr_number} with {merge_method}...")
        merge_flag = f"--{merge_method}"
        self._run_command([
            "gh", "pr", "merge", str(pr_number),
            merge_flag
        ])
        self._success(f"PR #{pr_number} merged")

        # Close issue
        self._info(f"Closing issue #{issue_number}...")
        self._run_command([
            "gh", "issue", "close", str(issue_number),
            "--reason", "completed"
        ])
        self._success(f"Issue #{issue_number} closed")

        # Update project status if project number provided
        if project_number:
            self._info("Updating project status to 'Done'...")
            success = self._update_project_item_status(project_number, issue_number, "Done")
            if not success:
                self._warning("Could not update project status automatically - please update manually")

        # Clean up worktree
        worktree_path = self.repo_path.parent / f"{self.repo_name}-story-{issue_number}"
        branch_name = f"feature/story-{issue_number}"

        if worktree_path.exists():
            self._info(f"Cleaning up worktree at {worktree_path}...")
            self._run_command([
                "git", "worktree", "remove", str(worktree_path)
            ])
            self._success("Worktree removed")

        # Prune worktree references
        self._run_command(["git", "worktree", "prune"])

        # Now safe to delete the local branch
        self._info(f"Deleting local branch {branch_name}...")
        self._run_command([
            "git", "branch", "-D", branch_name
        ], check=False)  # Don't fail if branch already deleted
        self._success("Local branch deleted")

        self._header("Story Complete! ðŸŽ‰")
        print(f"  Story #{issue_number} has been merged and closed")
        print(f"  Worktree cleaned up")
        print(f"  Ready to start the next story!")

        return True


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="GitHub Projects Helper - Streamline story-based development workflow",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # List all projects
  %(prog)s projects list

  # Get project statistics
  %(prog)s projects stats 1

  # Suggest stories to work on
  %(prog)s stories suggest 1 --milestone "Sprint 1-2"

  # Start working on a story
  %(prog)s story start 123 --project 1

  # Wait for PR checks to complete
  %(prog)s pr wait-checks 45

  # Complete a story (merge PR, close issue, cleanup)
  %(prog)s story complete 123
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    # Projects commands
    projects_parser = subparsers.add_parser("projects", help="Project operations")
    projects_subparsers = projects_parser.add_subparsers(dest="subcommand")

    projects_subparsers.add_parser("list", help="List all open projects")

    stats_parser = projects_subparsers.add_parser("stats", help="Get project statistics")
    stats_parser.add_argument("project_number", type=int, help="Project number")

    # Stories commands
    stories_parser = subparsers.add_parser("stories", help="Story operations")
    stories_subparsers = stories_parser.add_subparsers(dest="subcommand")

    suggest_parser = stories_subparsers.add_parser("suggest", help="Suggest candidate stories")
    suggest_parser.add_argument("project_number", type=int, help="Project number")
    suggest_parser.add_argument("--milestone", help="Filter by milestone")
    suggest_parser.add_argument("--priority", choices=["Critical", "High", "Medium", "Low"], help="Filter by priority")
    suggest_parser.add_argument("--limit", type=int, default=5, help="Number of suggestions (default: 5)")

    # Story commands
    story_parser = subparsers.add_parser("story", help="Individual story operations")
    story_subparsers = story_parser.add_subparsers(dest="subcommand")

    start_parser = story_subparsers.add_parser("start", help="Start working on a story")
    start_parser.add_argument("issue_number", type=int, help="Issue number")
    start_parser.add_argument("--project", type=int, help="Project number (optional)")

    complete_parser = story_subparsers.add_parser("complete", help="Complete a story (merge, close, cleanup)")
    complete_parser.add_argument("issue_number", type=int, help="Issue number")
    complete_parser.add_argument("--pr", type=int, help="PR number (auto-detected if not provided)")
    complete_parser.add_argument("--merge-method", choices=["squash", "merge", "rebase"], default="squash", help="Merge method (default: squash)")
    complete_parser.add_argument("--project", type=int, help="Project number (for status update)")

    # PR commands
    pr_parser = subparsers.add_parser("pr", help="Pull request operations")
    pr_subparsers = pr_parser.add_subparsers(dest="subcommand")

    wait_parser = pr_subparsers.add_parser("wait-checks", help="Wait for PR checks to complete")
    wait_parser.add_argument("pr_number", type=int, help="PR number")
    wait_parser.add_argument("--timeout", type=int, default=1800, help="Timeout in seconds (default: 1800)")
    wait_parser.add_argument("--poll-interval", type=int, default=30, help="Poll interval in seconds (default: 30)")

    # Status update commands
    status_parser = subparsers.add_parser("status", help="Update project item status")
    status_subparsers = status_parser.add_subparsers(dest="subcommand")

    update_parser = status_subparsers.add_parser("update", help="Update story status in project")
    update_parser.add_argument("issue_number", type=int, help="Issue number")
    update_parser.add_argument("status", help="Status to set (e.g., 'Pending Review', 'In Progress', 'Done')")
    update_parser.add_argument("--project", type=int, required=True, help="Project number")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Initialize helper
    helper = GitHubProjectsHelper()

    # Route commands
    try:
        if args.command == "projects":
            if args.subcommand == "list":
                helper.list_projects()
            elif args.subcommand == "stats":
                helper.get_project_stats(args.project_number)

        elif args.command == "stories":
            if args.subcommand == "suggest":
                helper.suggest_stories(
                    args.project_number,
                    milestone=args.milestone,
                    priority=args.priority,
                    limit=args.limit
                )

        elif args.command == "story":
            if args.subcommand == "start":
                result = helper.start_story(args.issue_number, args.project)
                # Output JSON for programmatic use
                print(f"\n{json.dumps(result, indent=2)}")
            elif args.subcommand == "complete":
                helper.complete_story(args.issue_number, args.pr, args.merge_method, args.project)

        elif args.command == "pr":
            if args.subcommand == "wait-checks":
                result = helper.wait_for_checks(args.pr_number, args.timeout, args.poll_interval)
                # Output JSON for programmatic use
                print(f"\n{json.dumps(result, indent=2)}")

        elif args.command == "status":
            if args.subcommand == "update":
                helper._update_project_item_status(args.project, args.issue_number, args.status)

    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}Error: {e}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
