#!/usr/bin/env python3
"""
GitHub Projects Helper
A CLI tool to streamline GitHub Projects operations for story-based development workflow.
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class Colors:
    """ANSI color codes for terminal output."""
    RESET = '\033[0m'
    BOLD = '\033[1m'
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'


class GitHubProjectsHelper:
    """Helper class for GitHub Projects operations."""

    def __init__(self, repo_path: str = "."):
        self.repo_path = Path(repo_path).resolve()
        self.owner = None
        self.repo_name = None
        self._load_repo_info()

    def _load_repo_info(self):
        """Load repository owner and name from git remote."""
        try:
            result = self._run_command(
                ["gh", "repo", "view", "--json", "owner,name"],
                capture_output=True
            )
            data = json.loads(result.stdout)
            self.owner = data["owner"]["login"]
            self.repo_name = data["name"]
        except Exception as e:
            self._error(f"Failed to load repository info: {e}")
            sys.exit(1)

    def _run_command(
        self,
        cmd: List[str],
        capture_output: bool = True,
        check: bool = True,
        cwd: Optional[Path] = None
    ) -> subprocess.CompletedProcess:
        """Run a shell command and return the result."""
        try:
            return subprocess.run(
                cmd,
                capture_output=capture_output,
                text=True,
                check=check,
                cwd=cwd or self.repo_path
            )
        except subprocess.CalledProcessError as e:
            self._error(f"Command failed: {' '.join(cmd)}")
            if e.stderr:
                print(e.stderr, file=sys.stderr)
            raise

    def _print(self, msg: str, color: str = Colors.RESET):
        """Print colored message."""
        print(f"{color}{msg}{Colors.RESET}")

    def _success(self, msg: str):
        """Print success message."""
        self._print(f"âœ“ {msg}", Colors.GREEN)

    def _error(self, msg: str):
        """Print error message."""
        self._print(f"âœ— {msg}", Colors.RED)

    def _warning(self, msg: str):
        """Print warning message."""
        self._print(f"âš  {msg}", Colors.YELLOW)

    def _info(self, msg: str):
        """Print info message."""
        self._print(f"â„¹ {msg}", Colors.CYAN)

    def _header(self, msg: str):
        """Print header message."""
        self._print(f"\n{Colors.BOLD}{msg}{Colors.RESET}", Colors.BLUE)

    # ==================== PROJECT OPERATIONS ====================

    def list_projects(self) -> List[Dict]:
        """List all projects for the repository owner."""
        self._header("Fetching projects...")

        result = self._run_command(
            ["gh", "project", "list", "--owner", self.owner, "--format", "json"]
        )
        data = json.loads(result.stdout)
        projects = [p for p in data.get("projects", []) if not p.get("closed", False)]

        if not projects:
            self._warning("No open projects found")
            return []

        for project in projects:
            self._print(f"\n{Colors.BOLD}Project #{project['number']}: {project['title']}{Colors.RESET}")
            print(f"  URL: {project['url']}")
            print(f"  Items: {project['items']['totalCount']}")
            if project.get('shortDescription'):
                print(f"  Description: {project['shortDescription']}")

        return projects

    def get_project_stats(self, project_number: int) -> Dict:
        """Get detailed statistics for a project."""
        self._header(f"Fetching project #{project_number} statistics...")

        result = self._run_command([
            "gh", "project", "item-list", str(project_number),
            "--owner", self.owner,
            "--format", "json",
            "--limit", "500"
        ])
        data = json.loads(result.stdout)
        items = data.get("items", [])

        if not items:
            self._warning("No items found in project")
            return {}

        # Calculate statistics
        stats = {
            "total": len(items),
            "by_status": {},
            "by_priority": {},
            "by_milestone": {},
            "by_effort": {},
            "by_category": {}
        }

        for item in items:
            # Status breakdown
            status = item.get("status", "Unknown")
            stats["by_status"][status] = stats["by_status"].get(status, 0) + 1

            # Priority breakdown
            priority = item.get("priority", "Unknown")
            stats["by_priority"][priority] = stats["by_priority"].get(priority, 0) + 1

            # Milestone breakdown
            milestone = item.get("milestone", {})
            if milestone:
                milestone_title = milestone.get("title", "No Milestone")
                stats["by_milestone"][milestone_title] = stats["by_milestone"].get(milestone_title, 0) + 1

            # Effort breakdown
            effort = item.get("effort", "Unknown")
            stats["by_effort"][effort] = stats["by_effort"].get(effort, 0) + 1

            # Category breakdown
            category = item.get("category", "Unknown")
            stats["by_category"][category] = stats["by_category"].get(category, 0) + 1

        # Print statistics
        self._print(f"\n{Colors.BOLD}Total Items: {stats['total']}{Colors.RESET}")

        self._print(f"\n{Colors.BOLD}By Status:{Colors.RESET}")
        for status, count in sorted(stats["by_status"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {status}: {count}")

        self._print(f"\n{Colors.BOLD}By Priority:{Colors.RESET}")
        priority_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3}
        for priority, count in sorted(stats["by_priority"].items(), key=lambda x: priority_order.get(x[0], 99)):
            emoji = {"Critical": "ðŸ”¥ðŸ”¥ðŸ”¥", "High": "ðŸ”¥ðŸ”¥", "Medium": "ðŸ”¥", "Low": "â­"}.get(priority, "")
            print(f"  {emoji} {priority}: {count}")

        self._print(f"\n{Colors.BOLD}By Milestone:{Colors.RESET}")
        for milestone, count in sorted(stats["by_milestone"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {milestone}: {count}")

        self._print(f"\n{Colors.BOLD}By Effort:{Colors.RESET}")
        for effort, count in sorted(stats["by_effort"].items(), key=lambda x: x[1], reverse=True):
            print(f"  {effort}: {count}")

        return stats

    # ==================== STORY OPERATIONS ====================

    # TODO: Add story/issue creation functionality
    # Similar to the scripts used before to create all the UX improvement issues
    # Should support:
    # - Creating issues from templates or JSON input
    # - Auto-assigning to projects
    # - Setting fields (priority, effort, milestone, category)
    # - Bulk creation from CSV/JSON files
    # - Template-based issue creation with variable substitution
    # Example: ./scripts/github-projects-helper stories create --from-file stories.json --project 1

    # TODO: Implement GitHub Projects V2 status updates via GraphQL
    # Current limitation: Status updates require GraphQL mutations with multiple IDs:
    # - Project ID (global ID, not project number)
    # - Project Item ID (the issue's ID within the project)
    # - Status Field ID
    # - Status Option IDs (for "In Progress", "Pending Review", "Done", etc.)
    #
    # These IDs must be fetched via GraphQL queries first, then used in mutations.
    # The gh CLI doesn't provide a simple way to update project fields.
    #
    # Implementation approach:
    # 1. Add method to fetch and cache project field metadata
    # 2. Add method to update item status via GraphQL mutation
    # 3. Call in story_start() to set "In Progress"
    # 4. Document how to set "Pending Review" when PR is created
    # 5. Call in story_complete() to set "Done"
    #
    # See CLAUDE.md "GitHub API Notes" section for GraphQL query examples

    def suggest_stories(
        self,
        project_number: int,
        milestone: Optional[str] = None,
        priority: Optional[str] = None,
        limit: int = 5
    ) -> List[Dict]:
        """Suggest candidate stories to work on."""
        self._header("Analyzing candidate stories...")

        result = self._run_command([
            "gh", "project", "item-list", str(project_number),
            "--owner", self.owner,
            "--format", "json",
            "--limit", "500"
        ])
        data = json.loads(result.stdout)
        items = data.get("items", [])

        # Filter eligible stories
        candidates = []
        for item in items:
            status = item.get("status", "")
            item_priority = item.get("priority", "")
            item_milestone = item.get("milestone", {}).get("title", "") if item.get("milestone") else ""

            # Filter criteria
            if status not in ["Todo", "Ready"]:
                continue
            if priority and item_priority != priority:
                continue
            if milestone and item_milestone != milestone:
                continue

            # Calculate score for prioritization
            priority_scores = {"Critical": 10, "High": 7, "Medium": 5, "Low": 3}
            effort_scores = {"Low 1d-2s": 3, "Medium 3d-5d": 2, "High 5d-10d": 1}

            score = priority_scores.get(item_priority, 0) + effort_scores.get(item.get("effort", ""), 0)

            candidates.append({
                "item": item,
                "score": score
            })

        # Sort by score and limit
        candidates.sort(key=lambda x: x["score"], reverse=True)
        top_candidates = candidates[:limit]

        if not top_candidates:
            self._warning("No candidate stories found matching criteria")
            return []

        self._print(f"\n{Colors.BOLD}Top {len(top_candidates)} Candidate Stories:{Colors.RESET}\n")

        for i, candidate in enumerate(top_candidates, 1):
            item = candidate["item"]
            content = item.get("content", {})
            number = content.get("number", "?")
            title = item.get("title", "Untitled")
            priority_val = item.get("priority", "Unknown")
            effort = item.get("effort", "Unknown")
            milestone_val = item.get("milestone", {}).get("title", "No Milestone") if item.get("milestone") else "No Milestone"

            priority_emoji = {"Critical": "ðŸ”¥ðŸ”¥ðŸ”¥", "High": "ðŸ”¥ðŸ”¥", "Medium": "ðŸ”¥", "Low": "â­"}.get(priority_val, "")

            self._print(f"{i}. {Colors.BOLD}#{number}: {title}{Colors.RESET}")
            print(f"   Priority: {priority_emoji} {priority_val}")
            print(f"   Effort: {effort}")
            print(f"   Milestone: {milestone_val}")
            print(f"   Score: {candidate['score']}/13")
            print()

        return [c["item"] for c in top_candidates]

    def start_story(self, issue_number: int, project_number: Optional[int] = None) -> Dict:
        """
        Start working on a story:
        1. Create worktree with feature branch
        2. Copy environment files
        3. Assign issue to current user
        4. Update project status to "In Progress"
        """
        self._header(f"Starting work on story #{issue_number}...")

        # Get issue details
        self._info("Fetching issue details...")
        result = self._run_command([
            "gh", "issue", "view", str(issue_number),
            "--json", "number,title,body,labels,milestone"
        ])
        issue = json.loads(result.stdout)

        # Create branch and worktree
        branch_name = f"feature/story-{issue_number}"
        worktree_path = self.repo_path.parent / f"{self.repo_name}-story-{issue_number}"

        self._info(f"Creating worktree at {worktree_path}...")

        if worktree_path.exists():
            self._error(f"Worktree already exists at {worktree_path}")
            sys.exit(1)

        self._run_command([
            "git", "worktree", "add", "-b", branch_name, str(worktree_path)
        ])
        self._success(f"Worktree created: {worktree_path}")

        # Copy environment files
        env_file = self.repo_path / ".env.local"
        if env_file.exists():
            self._info("Copying .env.local file...")
            target_env = worktree_path / ".env.local"
            target_env.write_text(env_file.read_text())
            self._success("Environment files copied")
        else:
            self._warning(".env.local not found - you may need to create it manually")

        # Assign issue to current user
        self._info("Assigning issue to you...")
        self._run_command([
            "gh", "issue", "edit", str(issue_number),
            "--add-assignee", "@me"
        ])
        self._success("Issue assigned")

        # Update project status if project number provided
        if project_number:
            self._info("Updating project status to 'In Progress'...")
            # Note: This requires GraphQL and field IDs, which is complex
            # For now, we'll skip this and let the user do it manually
            self._warning("Project status update not yet implemented - please update manually")

        # Print summary
        self._header("Setup Complete!")
        print(f"  Worktree: {Colors.GREEN}{worktree_path}{Colors.RESET}")
        print(f"  Branch: {Colors.GREEN}{branch_name}{Colors.RESET}")
        print(f"  Issue: {Colors.GREEN}#{issue_number}: {issue['title']}{Colors.RESET}")
        print(f"\n  Next steps:")
        print(f"    1. Plan the work: Ask Claude to 'plan work for story #{issue_number}'")
        print(f"    2. The worktree is ready at: {worktree_path}")

        return {
            "worktree_path": str(worktree_path),
            "branch_name": branch_name,
            "issue_number": issue_number,
            "issue_title": issue["title"]
        }

    # ==================== PR OPERATIONS ====================

    def wait_for_checks(self, pr_number: int, timeout: int = 1800, poll_interval: int = 30) -> Dict:
        """
        Wait for PR checks to complete (Vercel, SonarCloud).
        Returns status of all checks.
        """
        self._header(f"Waiting for PR #{pr_number} checks to complete...")
        self._info(f"Timeout: {timeout}s, Poll interval: {poll_interval}s")

        start_time = time.time()

        while True:
            elapsed = time.time() - start_time
            if elapsed > timeout:
                self._error("Timeout waiting for checks to complete")
                sys.exit(1)

            # Get check status
            result = self._run_command([
                "gh", "pr", "checks", str(pr_number),
                "--json", "name,state,bucket"
            ])
            checks = json.loads(result.stdout)

            # Find Vercel and SonarCloud checks
            vercel_check = next((c for c in checks if "vercel" in c["name"].lower()), None)
            sonar_check = next((c for c in checks if "sonar" in c["name"].lower()), None)

            if not vercel_check and not sonar_check:
                self._warning("No Vercel or SonarCloud checks found - waiting...")
                time.sleep(poll_interval)
                continue

            # Checks are done when state is SUCCESS or FAILURE (not IN_PROGRESS or PENDING)
            vercel_done = vercel_check and vercel_check.get("state") in ["SUCCESS", "FAILURE", "CANCELLED"] if vercel_check else True
            sonar_done = sonar_check and sonar_check.get("state") in ["SUCCESS", "FAILURE", "CANCELLED"] if sonar_check else True

            # Print status
            status_line = f"[{int(elapsed)}s] "
            if vercel_check:
                status_line += f"Vercel: {vercel_check.get('state', 'UNKNOWN')} "
            if sonar_check:
                status_line += f"SonarCloud: {sonar_check.get('state', 'UNKNOWN')}"
            print(status_line)

            if vercel_done and sonar_done:
                break

            time.sleep(poll_interval)

        # Print final results
        self._header("Checks Complete!")

        results = {}
        if vercel_check:
            bucket = vercel_check.get("bucket", "UNKNOWN")
            state = vercel_check.get("state", "UNKNOWN")
            # bucket can be: pass, fail, pending
            # Use state for more accurate status
            if bucket == "pass" or state == "SUCCESS":
                self._success(f"Vercel: PASS")
                results["vercel"] = "PASS"
            elif bucket == "fail":
                self._error(f"Vercel: FAIL")
                results["vercel"] = "FAIL"
            else:
                self._warning(f"Vercel: {bucket}")
                results["vercel"] = bucket

        if sonar_check:
            bucket = sonar_check.get("bucket", "UNKNOWN")
            state = sonar_check.get("state", "UNKNOWN")
            if bucket == "pass" or state == "SUCCESS":
                self._success(f"SonarCloud: PASS")
                results["sonar"] = "PASS"
            elif bucket == "fail":
                self._error(f"SonarCloud: FAIL")
                results["sonar"] = "FAIL"
            else:
                self._warning(f"SonarCloud: {bucket}")
                results["sonar"] = bucket

        # Get PR URL for preview
        result = self._run_command([
            "gh", "pr", "view", str(pr_number),
            "--json", "url"
        ])
        pr_data = json.loads(result.stdout)
        print(f"\nPR URL: {pr_data['url']}")

        return results

    def complete_story(
        self,
        issue_number: int,
        pr_number: Optional[int] = None,
        merge_method: str = "squash"
    ) -> bool:
        """
        Complete a story:
        1. Verify checks pass
        2. Merge PR
        3. Close issue
        4. Clean up worktree
        """
        self._header(f"Completing story #{issue_number}...")

        # Find PR if not provided
        if not pr_number:
            self._info("Finding PR for story...")
            result = self._run_command([
                "gh", "pr", "list",
                "--head", f"feature/story-{issue_number}",
                "--json", "number",
                "--limit", "1"
            ])
            prs = json.loads(result.stdout)
            if not prs:
                self._error(f"No PR found for story #{issue_number}")
                sys.exit(1)
            pr_number = prs[0]["number"]
            self._success(f"Found PR #{pr_number}")

        # Check if PR is mergeable
        self._info("Checking if PR is mergeable...")
        result = self._run_command([
            "gh", "pr", "view", str(pr_number),
            "--json", "mergeable,state"
        ])
        pr_data = json.loads(result.stdout)

        if pr_data["state"] != "OPEN":
            self._error(f"PR is not open (state: {pr_data['state']})")
            sys.exit(1)

        if pr_data["mergeable"] != "MERGEABLE":
            self._error(f"PR is not mergeable (status: {pr_data['mergeable']})")
            sys.exit(1)

        # Merge PR (don't delete branch yet - worktree still using it)
        self._info(f"Merging PR #{pr_number} with {merge_method}...")
        merge_flag = f"--{merge_method}"
        self._run_command([
            "gh", "pr", "merge", str(pr_number),
            merge_flag
        ])
        self._success(f"PR #{pr_number} merged")

        # Close issue
        self._info(f"Closing issue #{issue_number}...")
        self._run_command([
            "gh", "issue", "close", str(issue_number),
            "--reason", "completed"
        ])
        self._success(f"Issue #{issue_number} closed")

        # Clean up worktree
        worktree_path = self.repo_path.parent / f"{self.repo_name}-story-{issue_number}"
        branch_name = f"feature/story-{issue_number}"

        if worktree_path.exists():
            self._info(f"Cleaning up worktree at {worktree_path}...")
            self._run_command([
                "git", "worktree", "remove", str(worktree_path)
            ])
            self._success("Worktree removed")

        # Prune worktree references
        self._run_command(["git", "worktree", "prune"])

        # Now safe to delete the local branch
        self._info(f"Deleting local branch {branch_name}...")
        self._run_command([
            "git", "branch", "-D", branch_name
        ], check=False)  # Don't fail if branch already deleted
        self._success("Local branch deleted")

        self._header("Story Complete! ðŸŽ‰")
        print(f"  Story #{issue_number} has been merged and closed")
        print(f"  Worktree cleaned up")
        print(f"  Ready to start the next story!")

        return True


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="GitHub Projects Helper - Streamline story-based development workflow",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # List all projects
  %(prog)s projects list

  # Get project statistics
  %(prog)s projects stats 1

  # Suggest stories to work on
  %(prog)s stories suggest 1 --milestone "Sprint 1-2"

  # Start working on a story
  %(prog)s story start 123 --project 1

  # Wait for PR checks to complete
  %(prog)s pr wait-checks 45

  # Complete a story (merge PR, close issue, cleanup)
  %(prog)s story complete 123
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to run")

    # Projects commands
    projects_parser = subparsers.add_parser("projects", help="Project operations")
    projects_subparsers = projects_parser.add_subparsers(dest="subcommand")

    projects_subparsers.add_parser("list", help="List all open projects")

    stats_parser = projects_subparsers.add_parser("stats", help="Get project statistics")
    stats_parser.add_argument("project_number", type=int, help="Project number")

    # Stories commands
    stories_parser = subparsers.add_parser("stories", help="Story operations")
    stories_subparsers = stories_parser.add_subparsers(dest="subcommand")

    suggest_parser = stories_subparsers.add_parser("suggest", help="Suggest candidate stories")
    suggest_parser.add_argument("project_number", type=int, help="Project number")
    suggest_parser.add_argument("--milestone", help="Filter by milestone")
    suggest_parser.add_argument("--priority", choices=["Critical", "High", "Medium", "Low"], help="Filter by priority")
    suggest_parser.add_argument("--limit", type=int, default=5, help="Number of suggestions (default: 5)")

    # Story commands
    story_parser = subparsers.add_parser("story", help="Individual story operations")
    story_subparsers = story_parser.add_subparsers(dest="subcommand")

    start_parser = story_subparsers.add_parser("start", help="Start working on a story")
    start_parser.add_argument("issue_number", type=int, help="Issue number")
    start_parser.add_argument("--project", type=int, help="Project number (optional)")

    complete_parser = story_subparsers.add_parser("complete", help="Complete a story (merge, close, cleanup)")
    complete_parser.add_argument("issue_number", type=int, help="Issue number")
    complete_parser.add_argument("--pr", type=int, help="PR number (auto-detected if not provided)")
    complete_parser.add_argument("--merge-method", choices=["squash", "merge", "rebase"], default="squash", help="Merge method (default: squash)")

    # PR commands
    pr_parser = subparsers.add_parser("pr", help="Pull request operations")
    pr_subparsers = pr_parser.add_subparsers(dest="subcommand")

    wait_parser = pr_subparsers.add_parser("wait-checks", help="Wait for PR checks to complete")
    wait_parser.add_argument("pr_number", type=int, help="PR number")
    wait_parser.add_argument("--timeout", type=int, default=1800, help="Timeout in seconds (default: 1800)")
    wait_parser.add_argument("--poll-interval", type=int, default=30, help="Poll interval in seconds (default: 30)")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Initialize helper
    helper = GitHubProjectsHelper()

    # Route commands
    try:
        if args.command == "projects":
            if args.subcommand == "list":
                helper.list_projects()
            elif args.subcommand == "stats":
                helper.get_project_stats(args.project_number)

        elif args.command == "stories":
            if args.subcommand == "suggest":
                helper.suggest_stories(
                    args.project_number,
                    milestone=args.milestone,
                    priority=args.priority,
                    limit=args.limit
                )

        elif args.command == "story":
            if args.subcommand == "start":
                result = helper.start_story(args.issue_number, args.project)
                # Output JSON for programmatic use
                print(f"\n{json.dumps(result, indent=2)}")
            elif args.subcommand == "complete":
                helper.complete_story(args.issue_number, args.pr, args.merge_method)

        elif args.command == "pr":
            if args.subcommand == "wait-checks":
                result = helper.wait_for_checks(args.pr_number, args.timeout, args.poll_interval)
                # Output JSON for programmatic use
                print(f"\n{json.dumps(result, indent=2)}")

    except KeyboardInterrupt:
        print("\n\nOperation cancelled by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Colors.RED}Error: {e}{Colors.RESET}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
